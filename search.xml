<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html中的#及点击1000000问题]]></title>
    <url>%2F2019%2F03%2F22%2Fhtml%E4%B8%AD%E7%9A%84%23%E5%8F%8A%E7%82%B9%E5%87%BB1000000%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[emmm html中的#及点击1000000问题html中#的意思在HTML语言当中的#是没有意义的，但是，#会出现在2个其他地方，分别是CSS以及a标签的href当中。1 当#出现在CSS当中时，也就是CSS选择器当中时#选择器名称 { }这样的语法，表示的是“id类型的选择器”，比如如下代码，表示的就是id名为h5course的选择器#h5course { }但需要注意的是，在CSS当中书写的是 #+选择器名，而在HTML结构标签当中，则是用id去定义属性 HTML5 2 当#出现在a标签的href属性当中时 #表示的是锚链接 锚链接是2008年左右的WEB前端开发产物，可以简单的理解为在一个页面当中，跳转到某个页面位置的链接 比如： ``点击后跳转到test位置 接收锚链接的则是使用name属性，比如： ``#后面的为锚链接的名字，接收的标签与a当中的锚链接名称应当相同 ## 点击1000000次问题 ## 遇到的次数太多，总结一下 第一种方法，直接Fn+F12，在控制台or别的地方直接修改源代码，将clicks改为满足条件的值 第二种方法，跟据源代码，post or get `clicks=1000000000` 其源代码一般为：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Segmentation fault (core dumped)解决方法]]></title>
    <url>%2F2018%2F12%2F23%2FSegmentation-fault-core-dumped-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[emmmm Segmentation fault (core dumped)解决方法应该是c=a+b,没有注意到,才出现了该错误，考完试再来看 参考网站：https://blog.csdn.net/iohboel/article/details/51474335]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 守护进程编写]]></title>
    <url>%2F2018%2F12%2F21%2Flinux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[linuxC复习的时候，看到的守护进程的定义，百度了一波，并不是很懂 转：https://blog.csdn.net/zg_hover/article/details/2553321]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSFUCK编码]]></title>
    <url>%2F2018%2F12%2F16%2FJSFUCK%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[其实之前做题的时候有遇到过，但是不懂，这次又遇到了呢，有了些理解，bugku真的太适合新手了叭 JSFUCK编码格式：由()+[]!6个字符组成在黑客行为中，你的js代码可能被关键词检测，于是考虑躲避关键词检测的想法，例如 eval等关键词。（用上述6个字符替代关键词等）用途： 脚本注入时防止过滤 一定程度加密关键代码（生成代码很长，不适合加密大量代码。只能一定程度上加密，不能依赖）例题： [][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()放到控制台运行，会有弹框hello源码：alert(&quot;hello&quot;)参考网站：https://www.cnblogs.com/chianquan/p/5671474.html]]></content>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的匹配]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[正则表达式，因为之前python学过，感觉就各种匹配嘛，还是蛮简单的，然而事实上却是看不懂，不会做，故而今天做一下总结。（正则表达式真的是过分，哼） 正则表达式的匹配例子先来看个例子：/^\w+$/i 两个/ / 表明正则表达式的开始与结束 ^开始字符，$结束字符 \w 包含【a-z,A-Z,,0-9】中的字符，+代表可以有一个，或多个\w 后面的一个i是不区分大小写，其实放在这里没用了，因为\w包含着大小写 总的加起来意思是 以[a-z,A-Z,,0-9]中的其中一个字符开始，中间可以有任意个[a-z,A-Z,,0-9]字符，最后再以[a-z,A-Z,,0-9]中的一个字符结束 比如适合的有：a,a09,a_01,001 不适合的有a-5，@12，￥12，中文字符，这些都不在[a-z,A-Z,_,0-9]范围里面 具体各种字符的含义等我去换个markdown的破解版。。。。再上图（百度到的key，那个人也太好了叭）（百度就好）其他的一些字符的含义：https://blog.csdn.net/qq_38314112/article/details/81026648 参考网站：https://zhidao.baidu.com/question/589140079.htmlhttps://blog.csdn.net/qq_38314112/article/details/81026648]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php$$a的意思]]></title>
    <url>%2F2018%2F12%2F15%2Fphp%24%24a%E7%9A%84%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[解释$$a $first =&quot;hello&quot;; $hello =&quot;world&quot;; echo $first.&quot; &quot;.$$first;结果是 hello world$$first就是$hello，因为$first的值是hello做题的时候，可以利用该性质和GLOBALS找到flag]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中GLOBALS与global]]></title>
    <url>%2F2018%2F12%2F15%2Fphp%E4%B8%ADGLOBALS%E4%B8%8Eglobal%2F</url>
    <content type="text"><![CDATA[今天的000很勤奋，做了题目，主要是那个网站前几道题简单，做起来信心大增呀。这里主要说的是php中GLOBALS和globa的使用 php中GLOBALS与global（我我我也太懒了吧，说的挺详细的了）参考网站：https://blog.csdn.net/ybaog/article/details/52777967]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows hosts文件]]></title>
    <url>%2F2018%2F12%2F15%2Fwindows-hosts%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前百度如何翻墙的时候，了解过hosts文件，并不是很透彻，今天做了一道DNS解析域名的题目，对hosts文件的作用有了更深的理解 windows hosts文件的作用该文件位于C:\Windows\System32\drivers\etc，该文件是一个纯文本文件，用普通的文本编辑软件等记事本都能打开。 文件内容这个文件是根据TCP/IPforWindows的标准来工作的，它的作用是包含IP地址和Host name(主机名)的映射关系，是一个映射IP地址和Hostname(主机名)的规定，规定要求每段只能包括一个映射关系，IP地址要放在每段的最前面，空格后再写上映射的Host name(主机名)。对于这段的映射说明用“#”分割后用文字说明。 解析网站的域名的优先级我们知道在网络上访问网站，要首先通过DNS服务器把网络域名（www.XXXX.com）解析成XXX.XXX.XXX.XXX的IP地址后，我们的计算机才能访问。要是对于每个域名请求我们都要等待域名服务器解析后返回IP信息，这样访问网络的效率就会降低，而Hosts文件就能提高解析效率。根据Windows系统规定，在进行DNS请求以前，Windows系统会先检查自己的Hosts文件中是否有这个地址映射关系，如果有则调用这个IP地址映射，如果没有再向已知的DNS 服务器提出域名解析。也就是说Hosts的请求级别比DNS高。 用途 加快域名解析对于要经常访问的网站，我们可以通过在Hosts中配置域名和IP的映射关系，这样当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。 方便局域网用户在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务要输入难记的IP地址，对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候我们输入这个服务器的名字就行了。 屏蔽网站现在有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或自己计算机的IP，这样就不用访问了。我们在Hosts写上以下内容： 0.0.1#屏蔽的网站 0.0.0#屏蔽的网站这样计算机解析域名就解析到本机或错误的IP，达到了屏蔽的目的。 顺利连接系统对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。最后要指出的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。 保存修改后的hosts文件hosts修改后无法直接保存，可复制到桌面，修改后粘贴替换到原目录 参考网站：https://zhidao.baidu.com/question/5754099.html]]></content>
      <tags>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐写术初探]]></title>
    <url>%2F2018%2F11%2F17%2F%E9%9A%90%E5%86%99%E6%9C%AF%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[明天就要讲课了，，，还是他们的第一节课，，但我真的感觉啥都不会吖，没事，相信自己，好歹是大二的了，多多少少肯定会的比他们多一点儿嘛，大不了我就拽C语言，，好了，步入正题，这篇主要是关于图片隐写术的，属于入门还低一级别的？？？不过，还是有用的 隐写术初探隐写术定义：隐写术是关于信息隐藏，即不让计划的接收者之外的任何人知道信息的传递事件（而不只是信息的内容）的一门技巧与科学。（说白了，就是把信息藏起来不让别人看到，而像我们这种专业的CTF选手，就是要把人家隐藏的信息找出来啦）。 图像的结构想要攻击一个东西，肯定要先了解它一下嘛，不然怎么找到它的弱点呢，所谓知己知彼，百战百胜嘛，那么首先就是了解图像的结构喽。Gif:http://dev.gameres.com/Program/Visual/Other/GIFDoc.htmpng:https://my.oschina.net/ososchina/blog/801358jpg:https://blog.csdn.net/blues1021/article/details/45422557建议直接看png格式的结构，容易理解，然后再类比，很容易得出结论：图像的文件头都是固定的，都有自己的图像开始标志。常见的文件头文件尾：https://blog.csdn.net/xiangshangbashaonian/article/details/80156865（实在不知道的话，还可以自己下载一个相同格式的文件，然后拖到winhex（能观察到16进制数的一个工具）观察） 图种百度百科的解释很有意思呢，这里就不贴出来了，看它的名字就知道这是啥了呀，算了，还是贴出来吧，一种采用特殊方式将图片文件（如jpg格式）与rar文件结合起来的文件。该文件一般保存为jpg格式，可以正常显示图片，当有人获取该图片后，可以修改文件的后缀名，将图片改为rar压缩文件，并得到其中的数据。由于这种方式通常为了一些网友传播种子文件，故称为图种，又叫内涵图。正常的jpg文件尾是FF D9，(这里就是图片结构的知识啦，其实有用的不止文件头文件尾哦，还有些东西得我慢慢去挖掘呢，fighting)，遇到一张图片，右键查看属性没看出来啥的话，把他拖到winhex观察，如果发现不是正常结尾的，而是pk之类的，说明这张图片其实是个图种吖。生成图中的方法其实蛮简单的，利用cmd的cp命令：cp /b 1.jpg+2.rar 3.jpg,更改后缀名可解压或查看源文件。当然这只是针对添加的文件是压缩文件的情况，添加的文件也可以是其他图片，比如两张图片叠加。这时需要用binwalk 可以获得更详细的信息。(原谅我太菜，binwalk还没装好，虚拟机这个东西好难搞哇，哭辽)，使用啥的百度就好。 LSBLeast Significant Bit 最低有效位原理就是图片中的像数一般是由三种颜色组成，即三原色，由这三种原色可以组成其他各种颜色，例如在PNG图片的储存中，每个颜色会有8bit，LSB隐写就是修改了像数中的最低的1bit，在人眼看来是看不出来区别的，也把信息隐藏起来了。譬如我们想把’A’隐藏进来的话，如下图，就可以把A转成16进制的0x61再转成二进制的01100001，再修改为红色通道的最低位为这些二进制串。 隐写的载体是PNG的格式，如果是像之前的jpg图片的话就是不行的，原因是jpg图片对像数进行了有损的压缩，你修改的信息可能会被压缩的过程破坏。而PNG图片虽然也有压缩，但却是无损的压缩，这样子可以保持你修改的信息得到正确的表达，不至于丢失。BMP的图片也是一样的，是没有经过压缩的，可以发现BMP图片是特别的大的，因为BMP把所有的像数都按原样储存，没有压缩的过程。 可以用stegslove来分析，用python或matlab写脚本获得LSB组成一幅图像。 stegslove的使用file format:貌似第一个功能只可意会？？？人性化的显示它的数据块？？？感觉大概是这个样子的data extract:翻译说是数据提取，就勾选rgb三原色和Alpha通道值，preview后会提取出数据（有待摸索的，完全不知道这个有什么用呀）stereogram solver:这个，，，布吉岛……frame browser：分析gif图像的image combiner:双图分析呀 windows安装binwalk：http://www.cnblogs.com/pcat/p/5256288.html（大佬自己想办法的，我遇到这种问题，真的是不想搞的那种，向大佬学习） 参考：https://zhuanlan.zhihu.com/p/30539398]]></content>
      <tags>
        <tag>Steganography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php弱类型]]></title>
    <url>%2F2018%2F11%2F14%2Fphp%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[主要介绍web中的php弱类型 php弱类型php弱类型产生的原因，php不需要用户主动定义变量，与python相似。在两个变量进行比较时，若两个变量类型不一样，会进行强制转换。下面主要介绍弱类型的几种类型。 比较操作符 $a===$b 首先比较ab类型，不相等，则返回false $a==$b 若两个变量类型不一样，会强制转换成相同的再进行比较 string与int类型的转换int转string $var=5; 方式1：$item=(string)$var; 方式2：$item=strval($var);string转int var_dump(intval(‘2’))//2 var_dump(intval(‘3abcd’))//3 var_dump(intval(‘ancd’))//0intval()转换的时候，会从字符串的开始进行转换直到遇到一个非数字的字符，即使无法转换字符串，intval()不会报错而是返回0.(小数形式的字符转化为整数采取四舍五入)例如,如这段代码： if(intval($a)&gt;1000){ mysql_query(“select * from news where id=”.$a) }这个时候$a的值有可能是1002 union……16进制的转换以0x开头的字符串，php会将此字符串转化成十进制的在进行比较 “0x1e240”==”123456”//true “0x1e240”==123456//true “0x1e240”==”1e240”//false0x1e240解析成为十进制就是123456hash比较 “0e132456789”==”0e126723627” //true “0e123456abc”==”0e1ddda” //false “0e1abc”==”0” //true 在进行比较运算时，如果遇到了0e\d+这种字符串，就会将这种字符串解析为科学计数法。所以上面例子中2个数的值都是0因而就相等了。如果不满足0e\d+这种模式就不会相等。这个题目在攻防平台中的md5 collision就有考到。 内置函数参数的松散性在调用函数时传递给函数无法接入的参数类型 md5 $array1[] = array( “foo” =&gt; “bar”, “bar” =&gt; “foo”, ); $array2 = array(“foo”, “bar”, “hello”, “world”); var_dump(md5($array1)==var_dump($array2)); //true PHP手册中的md5()函数的描述是string md5 ( string $str [, bool $raw_output = false ] ) ，md5()中的需要是一个string类型的参数。但是当你传递一个array时，md5()不会报错，知识会无法正确地求出array的md5值，这样就会导致任意2个array的md5值都会相等。 strcmpstrcmp()函数在PHP官方手册中的描述是int strcmp ( string $str1 , string $str2 ) ,需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。如果传入的是数字： $array=[1,2,3]; var_dump(strcmp($array,’123’)); //null,在某种意义上null也就是相当于false。 switch()如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下： $i =”2abc”; switch ($i) { case 0: case 1: case 2: echo “i is less than 3 but not negative”; break; case 3: echo “i is 3”; } 这个时候程序输出的是i is less than 3 but not negative，是由于switch()函数将$i进行了类型转换，转换结果为2。 in_array在PHP手册中，in_array()函数的解释是bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) ,如果strict参数没有提供，那么in_array就会使用松散比较来判断$needle是否在$haystack中。当strince的值为true时，in_array()会比较needls的类型和haystack中的类型是否相同。 $array=[0,1,2,’3’]; var_dump(in_array(‘abc’, $array)); //true var_dump(in_array(‘1bc’, $array)); //true 可以看到上面的情况返回的都是true,因为’abc’会转换为0，’1bc’转换为1。array_search()与in_array()也是一样的问题。 参考网站：https://www.jb51.net/article/93447.htm]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客更新失败。。。]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%E3%80%82%E3%80%82%E3%80%82%2F</url>
    <content type="text"><![CDATA[博客这种东西，大概弄弄就好，再也不花时间在这个上面上了。 集训结束了，想放松放松，就想着换个主题，从github上搜索到一个我比较喜欢的主题，字体的颜色还可以变来变去，名字叫tomorrow，就很好看呀，我就想换这个呀。换主题的步骤总的来说就两步呀，可是，我弄完之后，博客进去之后却什么都没有，到这里还好，我之前备份了我以前的博客，结果，在git bash here时，进不去了，连git bash都打不开。。。。。后来也不知道为啥他又能打开了，不敢乱动，就从网上搜了一下1教程，一步一步的来的，然后换成功了，emmm，教程换的是next，有点不好看，想换回我原来的那个,我就想从网上在下载一次，这次在本地没有任何问题，但却deploy不上去，重新试了很多次，依旧不阔以，就像关掉重来，结果再开的时候，提示出错，说无法进行子进程什么的，我打开任务管理器，发现git居然在运行，之前每次都是关掉的呀，关掉之后重新运行就阔以了换next主题和spfk主题都可以，我又重新试了一下tomorrow，在本地都看不到，可能缺少了什么插件，可是用它的人还蛮多的呀，怎么在网上找不到教程，有时间再看吧有点生气，下次再也不乱换主题了]]></content>
  </entry>
  <entry>
    <title><![CDATA[shell懵逼中]]></title>
    <url>%2F2018%2F07%2F11%2Fshell%E6%87%B5%E9%80%BC%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[emmmmm,继前天的，今天讲了如何构造shellcode,以及利用shellcode得到shell。 如何构建shellcodeShellcode实际是一段代码（也可以是填充数据），是用来发送到服务器利用特定漏洞的代码，一般可以获取权限。system(“shell”)相当于execve(“/bin/sh”,0,0)，我们得到的shellcode即为execve(“/bin/sh”,0,0)的机器码。 1、为什么execve(“/bin/sh”,0,0)可以调用shell函数？（系统调用）在汇编代码后面加上int 0x80，可以实现系统调用，其中EAX寄存器中存被调用的编号，EBX存可执行文件，ECX和EDX存参数，表示一些环境变量。所以我们要调用shell，要实现的有以下步骤：EAX赋值为11，EBX赋为“/bin/sh”，ECX和EDX赋值为0，最后int 0x80。Section .text global _start _start: xor ecx, ecx mul ecx push ecx push 0x68732f2f push 0x6e69622f mov ebx, esp mov al, 0xb int 0x80但我们要注意：在这过程中容易出现坏字符，0x00表示截断，有其他的含义，解决办法为：比如mov eax,5，其实是mov eax,0x00000005,这时候用mov al,5;mov al 5的意思是mov eax,0x05，就不会出现0x00了。当然也可以通过绕过的方法：@#￥% 如何将其变为机器码①编译，将我们的汇编文件变成可执行文件，在Linux系统中，可执行文件后缀名被默认为.ELF,注意，在Linux系统中，所以东西都是文件或文件夹，而且没有分类，我们默认在其后面加入固定的字母以分类。代码：nasm -f elf64 shellcode.asm -o shellcode.o,其中-f表示文件形式输出，elf64表示64位系统，-o表示输出文件，shellcode.asm汇编代码写的文件，shellcode.o汇编代码执行后生成的可执行文件。②通过objdump -d shellcode.o可以获得我们需要的机器码，shellcode=”\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80”（21字节） 有关系统文件的一些特性在Linux系统下有Nx（No execute）,即不能执行，Windows下有Data Execution Prevention，即数据执行禁止，总的一句话，可执行的不可写，可写的不可执行，为了保证系统安全。 一些保护1、ASLR会随机改变栈、堆、共享库映射等线性区布局的随机化，即相差多少不会变，但是总体位置会进行偏移，关闭：sudo sh -c “echo 0 &gt; /proc/sys/kernel/randomize_va_space”，打开的话，把0改为2即可。2、栈保护天使关闭方法：在界面输入gcc -g hello.c -o hello -z execstack -fno-stack-protector，自行匹配 例题源码：第一种方法：大概意思：程序有gets函数，通过这个输入shellcode，再找到shellcode的地址，将该地址覆盖到原来填充返回地址的位置，即获得了shell。具体实现步骤：首先建立一个python脚本，payload那里先写入一个标记字符，然后通过该字符找到其写入位置，再在该位置输入shellcode，然后偏移量算出来后，在return address的位置写入我们找到的位置。建立python脚本，其中p32的意思是emmm，注意脚本中raw_input()的作用为让程序暂时停下以便于我们查找地址。运行python脚本，会产生一个pid，这时另开一个输入gdb attach pid,即可将gdb与python脚本连接起来。便可开始查找地址。因为python脚本中的raw_input，我们需要在python运行的那个界面按下回车才能继续运行因为此时在程序的比较内部的结构，我们可通过不断finish,直到看到A函数，这时我们输入searchmem 0xdeadbeef,便可找到其地址0xffffced8接下来找偏移量，与前天一样：修改脚本，再次连接将ASLR打开，这时候我们先找一个确定的位置再输入shellcode显然行不通，我们就需要利用文件本身的一些特性。具体步骤：开启aslrgdb 进入文件，start，然后输入vmmap,分析内存,发现第三行比较特别，它属于主程序，所以aslr保护并不能改变它的地址，而且他权限为可读可写可执行，称为bss,我们可以利用这一特性，来写入shellcode并执行。脚本文件如下，return address 的位置填上了gets函数的地址,相当于调用gets函数，后面两个，一个为参数，一个为返回地址，都填上bss的地址，我们第二次输入的时候便是在那个特殊的位置写入并执行。]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS]]></title>
    <url>%2F2018%2F07%2F08%2FXSS%2F</url>
    <content type="text"><![CDATA[今天主要了解了XSS攻击（跨站脚本攻击） 基本知识1、HTML超文本标记语言，标准通用标记语言下的一个应用。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。网页的本质就是超级文本标记语言，通过结合使用其他的Web技术（如：脚本语言、公共网关接口、组件等），可以创造出功能强大的网页。2、javascript(js)一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。Javascript的一些弹窗函数：1.alert() 用于提示2.confirm() 用于和用户交互确认3.prompt() 弹框让用户输入信息 XSS的概念XSS是一种出现在web应用程序中的计算机安全漏洞，是由于web对用户输入过滤不严而导致的，黑客通过“HTML注入”篡改网页，使用户在浏览时，就会执行其中的恶意脚本，从而获得用户的cookie信息 XSS分成两类：反射型XSS,存储型XSS 反射型XSS反射型跨站脚本也称作非持久型、参数型跨站脚本，这类型的脚本最常见，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中。一般使用的已经构造好的恶意URL发送给受害者，诱使受害者点击触发，只执行一次非持久化。反射型XSS过程 存储型XSS存储型XSS比反射型跨站脚本根据威胁，并且可能影响到web服务器的自身安全。此类XSS不需要用户点击特定的URL就能执行跨站脚本，攻击者事先将恶意JavaScript代码上传或存储到漏洞服务器中（例如在网页上输入一些评论（包含恶意代码），就会传送给数据库，只要用户浏览网页，我们就能获得相应信息），只要受害者浏览包含此恶意的代码页面就会执行恶意代码。存储型XSS过程 XSS限制绕过在测试的时候，我们可能会遇到我们输入的恶意代码某些字符被过滤掉，不能起到该起的作用，这时候我们就需要绕过这些限制了，主要有四种方法：一、二：如果是alert()之类的括号里的某些单引号被转义了之类的，例如，magic_quotes_gpc=ON 是php中的安全设置，开启后会把一些特殊字符进行轮换，如单引号会被转义为&#39;，此时我们可以将我们需要输的字符转化为ASCII码或者16进制形式，这时候，我们就能输出我们想要弹出的字符。转化为ASCII码的方式为：利用String.fromCharCode()函数将括号里的ASCII码值转化为我们想输的字符，注意，这里只是将ASCII码转化为我们需要的字符，并没有执行任何操作，在真正进行的时候，仍需JS的一些函数。转化为16进制：就是将我们要输入的字符转化为16进制，用法与转化为ASCII码值是一样的。三、改变大小写四、关闭标签在网页代码中输入框架中可能原本就有闭合符号，这时候我们利用闭合函数的形式来绕过闭合符号关闭标签 中高低等级下dvwa平台XSS题目检测是否有XSS漏洞反射型XSS：low:输入，其中前面的为头标签，带斜杠的表示尾标签，得到结果：说明有XSS漏洞medium:页面源码如下：我们可以看出，它把标签给替换成空了，这时候我们有两种方法绕过，第一种，标签大小写交替，第二种，换个标签high:源码：此时只能用替换标签的方法，图中的匹配替换，表示只要遇到script，无关大小写，都会被过滤 存储型： low:分别输入script标签，中间加各个js弹出框函数，发现我们建立第二个的时候，第一个框依旧会弹出，是因为存储型XSS将脚本文件发送到了数据库，每次用户访问该网页，改脚本均会执行 ![](https://i.imgur.com/EgkErH1.png) medium:源码： ![](https://i.imgur.com/7pK0MAi.png) 我们可以看到此时的message用了htmlspecialchars函数，输入的恶意代码转换成HTML实体，即我们无法通过在message框中输入js代码，那我们只能在name取输入代码，而name区允许输入长度较小，此时我们通过burpsuit抓包， ![](https://i.imgur.com/2TOimwp.png) 在图中位置输入我们想输入的代码，然后点击forward,即可以看到网页上弹出了一个框 high:源码： ![](https://i.imgur.com/e5UzKuI.png) 图中两处地方可以看出，我们不能在message区输入js代码，也不能用script标签，步骤与上题一样，只不过在改name的时候采用其他标签即可。 ## XSS盗取cookie登陆 ## 1、在本地编写一个接受cookie的PHP脚本： 2、构造攻击盗取cookie脚本 ![](https://i.imgur.com/4EScSAn.png) 具体步骤： 1、本地建立PHP文件 ![](https://i.imgur.com/XCOr9Yn.png) 在dvwa上输入恶意代码 ![](https://i.imgur.com/UHrDcAg.png) 页面会跳转到下图 ![](https://i.imgur.com/fAzkCI4.png) 本地会生成一个cookies文本文件 ![](https://i.imgur.com/7ouDYNy.png) 其中PHPSESSID即我们所需要的身份令牌，也就是cookies ![](https://i.imgur.com/5cSgSyQ.png) 换个浏览器重新打开登陆页面，右键检查，改一下信息，其中cookies为我们本地文件所获得的 ![](https://i.imgur.com/uSY214P.png) 然后输入网址http://127.0.0.1/dvwa/index.php，就能登陆了 ![](https://i.imgur.com/1GQmx8F.png)]]></content>
  </entry>
  <entry>
    <title><![CDATA[最简单的一道PWN]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E9%81%93PWN%2F</url>
    <content type="text"><![CDATA[emmmm，每天都能知道很多新东西呀，今天主要讲了栈帧平衡（stack frame）、缓冲区溢出（buffer overflow),还讲了一道据说非常简单的PWN：通过一个程序，利用上次和今天讲的，控制程序所在运行的电脑。 栈帧平衡栈帧平衡： 调用函数前后栈的结构不变要保证调用函数前后栈的结构不变，在开始时我们就应该记住栈的底部位置和顶部位置，方法：EBP指向栈底，ESP指向栈顶push EBP（将栈底地址保存在栈中,储存栈顶位置加上位置，此时栈顶为EBP的值）MOVE EBP ESP（将栈顶赋给栈底，此时栈顶指针和栈底指针都指向栈顶，后来进栈的，栈顶指针移动）上述操作进行结束，我们就可以进行我们所想进行的操作，进行操作过后，我们把EBP赋给ESP，此时两个指针指向原来栈的栈顶，POP函数的用法是POP出栈顶的值，POP EBP的意思是pop出栈顶的值赋给EBP。总的来说，流程如下： 函数调用与返回函数调用：首先存我们返回地址（函数调用结束后返回的地址），然后jump到函数的位置返回：pop出我们存的返回地址，然后jump 缓冲区溢出一个数组是用栈保存的，我们调用函数会把返回地址储存在栈中，我们输入值的时候，地址会从小到大，会先占用地址较小的地址，这时候我们如果不规定输入字符的数量，就有可能会覆盖掉我们存储的返回位置（retaddr:return address）,函数结束后会返回到一个莫名其妙的位置。 gdb命令GDB（GNU Debugger）是在lunix以及lunix系统下的调试工具。功能极其强大，几乎涵盖了你所需要的全部功能。GDB主要帮忙你完成下面四个方面的功能：1.启动你的程序，可以按照你的定制要求随心所欲的运行程序。2.可让被调试的程序在你所指定的调置的断点处停住。3.当程序被停住时，可以检查此时你的程序中所发生的事，以及内存状态等。4.动态的改变你程序的执行环境。gdb使用总旨：help指令很强大！多用help！help里面总会有你需要的信息。如果你不知道如何使用help，请在gdb里面输入：help all首先写一下今天要用到的一些命令：objdump -d 文件名：遍历程序，可以看到所有的汇编代码，保存之后可以寻找我们所想找的东西gdb 文件名：进入文件start：开始运行程序ni：逐步运行si：进入函数pattc n：随机生成有规律的n个字符patto 要查找的东西：查找 然后是其他的一些命令：f：显示格式 hex(hex) 按十六进制格式显示变量。 d(decimal) 按十进制格式显示变量。 u(unsigned decimal) 按十进制格式显示无符号整型。 o(octal) 按八进制格式显示变量。 t(binary) 按二进制格式显示变量。 a(address) 按十六进制格式显示变量。 c(char) 按字符格式显示变量。 f(float) 按浮点数格式显示变量 gcc -g main.c //在目标文件加入源代码的信息 gdb a.out (gdb) start //开始调试 (gdb) n //一条一条执行 (gdb) step/s //执行下一条，如果函数进入函数 (gdb) backtrace/bt //查看函数调用栈帧 (gdb) info/i locals //查看当前栈帧局部变量 (gdb) frame/f //选择栈帧，再查看局部变量 (gdb) print/p //打印变量的值 (gdb) finish //运行到当前函数返回 (gdb) set var sum=0 //修改变量值 (gdb) list/l 行号或函数名 //列出源码 (gdb) display/undisplay sum //每次停下显示变量的值/取消跟踪 (gdb) break/b 行号或函数名 //设置断点 (gdb) continue/c //连续运行 (gdb) info/i breakpoints //查看已经设置的断点 (gdb) delete breakpoints 2 //删除某个断点 (gdb) disable/enable breakpoints 3 //禁用/启用某个断点 (gdb) break 9 if sum != 0 //满足条件才激活断点 (gdb) run/r //重新从程序开头连续执行 (gdb) watch input[4] //设置观察点 (gdb) info/i watchpoints //查看设置的观察点 (gdb) x/7b input //打印存储器内容，b–每个字节一组，7–7组 (gdb) disassemble //反汇编当前函数或指定函数 (gdb) si // 一条指令一条指令调试 而 s 是一行一行代码 (gdb) info registers // 显示所有寄存器的当前值 (gdb) x/20 $esp //查看内存中开始的20个数 python pwntools 基本操作PwnTools的官网如下：http://pwntools.com/https://www.cnblogs.com/Ox9A82/p/5728149.html from pwn import *表示导入pwn库 context(arch = ‘i386’, os = ‘linux’)用来导入pwntools库 r = remote(‘exploitme.example.com’, 31337)设置目标机信息，用来建立一个远程连接，url或者ip作为地址，然后指明端口 r = process(“./test”)使用本地文件 例题一：下面是源代码：从源代码可以看出如果想进入cmd函数执行shell，由于主函数只调用了A这个函数，所以我们可以把A的返回地址给覆盖为cmd函数的地址，就可以进入cmd调用它了。首先输入objdump -d p1浏览它的汇编代码，我们可以看到cmd的地址为0804846b，但是一个指针四个字节，他是以小端序的方式存的，所以他在内存中存储形式为：6b 84 04 08然后进入文件p1start在下图中我们可以看到此时函数运行在Asi进入函数ni单步运行，直至找到scanfpattc 200生成200个随机字符，输入函数之前必须输入个c(contiue)将生成的随机字符复制粘贴，回车，可以看到有以下错误提示利用patto找到offset，为112然后利用pythontools，连接，输入以下东西，就是将字符串传递给我们的程序第二种方法：return 滑行，之前一直不懂，emmm，现在懂了，就是任意一个return地址复制个很多次填充rutaddr之前的东西，要保证我们输入的字符串要覆盖掉return address，所以要输入的足够多，然后在最后加上cmd的地址。过程：到A函数返回的地方，返回了一个返回地址，相当于又执行了一遍return函数，然后一直return，直至返回cmd，执行shell.前面找地址的步骤是一样的：找到一个return地址：然后在pythontools中改一下字符串：OK啦 二、源码如下：进入文件start根据源码能看出magic的地址与rand函数有关，可以看到调用rand函数之后将它产生的值赋给了magic，所以0xffffcf08-0x1c即为magic的地址buff数组用gets函数赋值，调用函数需传给它一个参数，即数组的首地址，这时候我们把两个变量的地址都找到了，可以看到两个地址之间差了100，magic整型变量，四个字节，只要保证buf的前四个与100到104的数相等即可利用pythontools交互得到shell]]></content>
      <tags>
        <tag>栈、PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[就简单的记了几道题的步骤，emmmm，记住步骤是第一步，emmmm，小姐姐那么可爱，必须努力写呀 文件上传漏洞上传的文件不进行限制，有可能会被利用上传可执行文件、脚本到服务器上，并且通过脚本文件可以获得获得执行服务器端命令的能力。 木马按照后台语言分类：asp一句话木马，JSP一句话木马，php一句话木马按照功能分类：大马、小马一句话木马举例：GET请求：一些有关GET请求的命令：GET方式可以直接在url后面加？和传入的参数，a=phpinfo（）查看有关php信息；a=dir查询当前目录下的文件目录；a=pwd查询当前文件上层目录；POST请求：上传包含一句话的木马后，用hackerbar在Post data里写执行的命令的参数，点执行一些有关post的命令：a=system(‘pwd’);a=system（’ls’）.上传木马文件后，利用AntSword输入URL以及参数，（大概是为了获得主机权限）操作步骤：点击data,添加，在弹出的框中对应位置输入URL和参数，值得注意的是URL应为你上传木马文件的位置，密码为你写的参数上传文件并连接过后，右键点击文件管理，此时就可以对主机的文件就行下载了 例题一、客户端javascript检测题目http://127.0.0.1/upload-labs/Pass-01/index.php由源码可以看出此时只比较文件后缀名是否一致，有两种方法解决。1、利用火狐插件hacker插件，打开设置，在图中地方打勾，此时即可上传木马文件，即php文件若上传成功，则网页此时会变成下面：同时在www目录下能找到我们上传的文件那么到此为止，我们的第一步上传木马就成功了，下面我们要通过AntSword连主机，找到我们需要的东西。首先新建连接，然后右键打开FileManager，成功会出现文件列表，但我又双叒叕不行了，觉得逻辑是没问题的，emmmmm第二种方法：先把文件改成符合条件的文件格式上传，再在抓包，修改文件的后缀名开启代理，打开burpsuit,上传文件，截包修改改变文件名的后缀名，以及Content-Type改成php的内容类型，然后点击go此时在根目录下可以看到我们上传的php文件，及上传成功，然后与上面一样的步骤，即可看到下面的图片：就成功啦 二、服务端检测绕过（MIME类型检测）此时看源代码可看出，它是通过检测文件内容类型来检测的，所以我们不能单纯的通过改文件后缀名来上传，而是上传php文件，然后抓包后修改文件Content-Type为所允许上传的类型，提交就可以了，但是在根目录下发现我上传了两个文件：不过不影响AntSword的连接和使用。 三、服务端目录路径检测这题比较坑。。。。。。http://127.0.0.1/upload-labs/Pass-11/index.php简单来说，这题就是我们在上传的时候，若上传文件成功，他会自动修改我们的文件路径，此时我们可以通过利用%00来截断文件后面的名字。修改路径和Content-Type即可然后，很神奇，我又在我的WWW目录下发现了两个文件：然而连接也是成功了的：哇，这题坑了我们一下午，有些东西不一定是我们逻辑上的错误，可能是软件本身或者电脑本身造成的困扰，所以大部分的时间都在被困在这些不重要却很烦的东西，真正逻辑上的原理，却并没有去关注它。 四、作业http://ctf5.shiyanbar.com/web/upload首先我们尝试直接上传php文件，结果：利用hackerbar关闭js，结果依旧如上图。（基本可以排除第一题那种情况啦，第二种的方法试一试）那我们就改变下文件后缀名为jpg，然后上传，依旧不成功：学安全的人都比较阔爱呀那就截包改变其Content-Type试试？结果是这个样子滴：文件是上传成功了，然而并没有flag, 幽灵/幽灵/幽灵是这个样子的，那就只能是第三种啦，这里有点特殊：第一处的修改为1.php加空格，然后加.jpg，原因：加一个什么空格之类的，是用来标记的，就是要填00的位置，就是开始截断的地方第二处将内容类型改成php的，点击go即可：OKKK,终于结束啦，感觉这是我做的最全的作业了]]></content>
      <tags>
        <tag>木马</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关SQL绕过和盲注]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%9C%89%E5%85%B3SQL%E7%BB%95%E8%BF%87%E5%92%8C%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[SQL注入的扩展，绕过和盲注（包括对SQL注入的理解） SQLSQL：结构化查询语言（Structured Query Language），一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名。 SQL注入网站对用户交互显示的内容存储在数据库中，网站的每个功能均会获取用户主动或被动输入的关键数据，而网站后端已封装好一个完整的SQL语句，将用户输入的关键数据放入SQL语句的固定查询点内，SQL查询以后，就会返回一个用户想要的内容，并利用用户的浏览器前端显示。而若用户输入的为SQL语言片段，片段放入固定查询点会破坏固定的SQL语句原有查询方法。若该片段是恶意的，可以达到使原有功能失效，而实际执行内容被控制的结果，恶意内容不断变化形式，可以从数据库中返回不应该被查到的数据。简单来说，就是输入一些SQL语句片段，从而达到自己想要的效果（获得不应该获得的数据或改变原有功能)。其本质是将用户的输入的数据，作为了命令来执行。 复习前天的一道题目首先进入10.21.13.97，进入DVWA，将DVWA security选到low级别，然后选择sql injection进入做题。根据步骤，第一步要判断其是否存在注入且其的SQL注入类型,输入1，出现id=1的信息，输入1’and ‘1’=’2,没有输出结果，输入1’ or ‘1’=’1,有以下结果此时可判断这里是字符型SQL注入（判断是否存在注入以及注入的类型根据输入不同的SQL语句片段得到不同的结果）第二步，猜字段（根据order by的性质）输入1’ or 1=1 order by 2 %23,返回正确结果而输入1’ or 1=1 order by 2 %23，返回错误，所以其字段为2第三步，确定显示字段顺序，输入1’ union select 1,2 %23第四步，通过字段查询数据库，输入1’ union select 1,database() %23第五步，查数据库中的表，输入1’ union select 1,group_concat(table_name) from information_schema.columns where table_schema=database() %23,第六步，查表中的字段，输入1’ union select 1,group_concat(column_name) from information_schema.cloumns where table_name=’users’ %23第七步，下载数据，输入1’ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat() from users %23 SQL绕过基本知识SQL注入的过程中有些特定的字符或者字符串会被过滤，数据库无法了解正确的查询语句，就没有办法进行SQL注入了绕过技术：1、运用编码技术绕过 运用ASCII码或者URL编码绕过2、采用重复的技术绕过 字符重复绕过3、采用大小写交替混用绕过 字符大小交替使用4、绕过空格 可用两个空格表示、用注释符号代替、用括号代替、用‘+’代替、用%a0代替、用花括号代替、用单引号双引号代替5、过滤information_schema.tables等关键表名 在schema与tables之间加空格6、过滤等号 用like代替等号7、过滤引号 十六进制代替引号8、过滤‘&gt;’，‘&lt;’ greatest()代替大于号，least()代替小于号9、过滤逗号 盲注的时候用到的substr()函数等需要用到逗号，这时用select substr(database() from 1 for 1) 代替select substr(database(),1,1);即可10、过滤sleep 时间型盲注会用到sleep函数，若该函数被过滤，采用benchmark(10000000,sha(1)) 10000000次sha(1)，来时间延迟，如果sleep中不能使用数字，用pi()函数绕过：sleep(ceil(pi()))（pi()为圆周率计算，ceil为向上取整函数）11.过滤注释符号（#，–+） id=1’ union select 1,2,3||’1(最后的||’1=or ‘1闭合查询语句的最后的单引号)12.过滤单引号13.采用大小写交替混用的绕过14.利用等价函数15.Mysql条件注释的利用 /*! … */例题打不开呀]]></content>
      <tags>
        <tag>SQL绕过、盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制基础]]></title>
    <url>%2F2018%2F07%2F03%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[寄存器、缓存、内存、硬盘的相关知识，以及栈和栈帧平衡，对swap函数用F10调试，用栈分析其过程 寄存器直接整合到CPU中的有限的高速访问速度的存储器，但是容量有限，所以一般只存储一些指令和使用频繁的数据，加快直接同内存读取指令和读写数据的速度。 缓存数据交换的缓冲区（称作Cache），当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。 内存与CPU进行沟通的桥梁，计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。 内存是由内存芯片、电路板、金手指等部分组成的。 硬盘用来存储需要永久存储的文件。CPU访问速度从快到慢排序为：寄存器-&gt;缓存-&gt;内存-&gt;硬盘 寄存器寻址参照汇编语言 小端序高位字节存储在高位，低位字节存储在低位数据在内存中一般以16进制储存，一个字节可以储存8个二进制位，一个16进制可以表示4个二进制位，所以一个字节可以存储2个16进制位，a在十六进制中表示十进制中的10，0-f均表示一个16进制位。例如：① Char [4] “pwn”Ascii ‘p’=70 ‘w’=77 ‘n’=6e(已经是16进制数了)一个字节存储一个字符，所以不需要用到小端序，其在内存中的存储为：70、77、6e、00，00为\0的16进制数。② int 0x1234 一个整型的可以存4个字节，此时需要对其进行排序，小端序排序，未排序之前是12，34；排序后高字节12排在高位置上，即右边，所以排序后，其存储形式应为：34，12。 栈和SWAP一、栈的特点：1、先进后出2、地址从高位到低位延伸，先进的在高地址，push栈的底部会下降，pop底部会上升这里上下两幅图都是可以表示栈的，由于栈的特性，我们只需要记住，栈底的地址较高，栈顶的地址较低即可二、栈的作用：1、暂时保存变量 //寄存器个数有限，运行函数需要寄存器，用栈保存省寄存器2、调用函数时传递参数（与接下来的SWAP连接在一起）3、保存函数返回地址 //调用函数，函数结束返回你调用的位置之后，利用了栈的先进后出的特点，即先调用的后返回三、SWAPa、b指要交换的两个数，aa为a的地址，bb为b的地址，*aa=a， *bb=b1、可以被交换分析过程：SWAP函数将aa地址对应的值与bb地址对应的值交换，结果为：主函数中a,b得值被交换，刚开始一直很迷，因为一直在用a,b进行入栈分析操作，所以觉得没变，事实上，a,b指示变量的名称。]]></content>
      <tags>
        <tag>SWAP函数，二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OD]]></title>
    <url>%2F2018%2F07%2F03%2FOD%2F</url>
    <content type="text"><![CDATA[OD 参考：https://qianfei11.github.io/2018/07/01/BIN%E9%9B%86%E8%AE%AD%EF%BC%88%E4%B8%80%EF%BC%89/ 调试od主要有四个窗口：我们主要作用于反汇编窗口。静态调试：不执行程序，人工分析源代码语法和逻辑动态调试：在编译、链接、运行的过程中，观察寄存器的变化等来分析调试 窗口按钮含义L：日志信息E：模块信息M：内存T：线程W：窗口信息H：句柄信息C：CPUK：调用链信息 OD调试快捷键略未完待续。。。。。。。]]></content>
      <tags>
        <tag>OD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[burpsuite介绍即一道简单的破解密码的题]]></title>
    <url>%2F2018%2F07%2F03%2Fburpsuite%E4%BB%8B%E7%BB%8D%E5%8D%B3%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E7%A0%B4%E8%A7%A3%E5%AF%86%E7%A0%81%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一道简单的爆破题 burpsuite介绍一道简单的破解密码的题网址：http://ctf4.shiyanbar.com/web/root/index.php解题步骤：1、网页右键查询源码信息，翻到最底部，复制password.txt,会有一个有很多数据的页面出现（我也不知道为什么要这么做）2、通过火狐插件FoxyProxy开启代理进行截包，在网页上输入密码，burpsuite会出现以下信息：然后右键send to Intruder,点击Payloads，在上面的图片中通过Paste键粘贴在password.txt界面上的数据，然后点击最上面一行的Intruder,选择Start attack,出现以下界面：有一个长度与其他长度不一样的，双击点进去：复制NsfOcuS到刚开始得到的界面1234那里，然后点击Forward，网页就会提示这里没有flag,就成功了。]]></content>
      <tags>
        <tag>不知道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql手工注入]]></title>
    <url>%2F2018%2F07%2F02%2Fsql%E6%B3%A8%E5%85%A5%E5%9F%BA%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[简单的sql手工注入即PHP基本知识 PHP语言基础PHP语言以结尾，在网站根目录下新建名为index.php文件，会被自动认为成主页，在网址输入localhost,即可得到你所运行的PHP文件。基本语法： 注释三种方式，#，//，/* */ 定义变量，不需要类型，$a，即定义了一个变量a，其他规则与C语言类似，注意它对大小写敏感 单引号不能解析变量，双引号可以 PHP语言中键值对，可以通过数字索引数组，也可以通过键访问值 ## 网络的三层架构 ## 用户向web服务器发送请求，web服务器运行代码，在数据库服务器中找到所要请求的东西，再返回给web服务器，由web服务器发给用户 URL：平常的网址，类型：协议：//授权/路径？查询(授权可以指域名或IP) 例如：https：//www.cobranet.org/about.php?id=1 ## GET请求和POST请求 ## GET和POST是HTTP中定义的客户端可以发送给服务器的两种操作 GET请求：用？分割URL和要查询的数据，例如上述网址，即要查询id=1的信息 POST请求：通过表单的方式访问，例如网站的登陆页面，输入名字，密码登陆，这种即为POST请求。 PHP连接到一个MySQL服务，通过mysql_connect()函数完成PHP连接到一个活动的数据库，用mysql_select_db()函数，用法：两个参数，第一个参数为之前安装的网站名字数据库，第二个为选择连接的数据库。从数据库里选取数据，使用mysql_query(),该函数用于向SQL发送查询命令。查询过数据需要输出我们才能看到数据库中的数据，输出用mysql_fetch_array（）函数，mysql_fetch_array函数从结果中取得一行作为关联数组，或数字数组，或二者兼有。返回根据从结果集取得的行生成的数组，如果没有更多则返回FALSE。用法：两个参数，第一个为经过mysql_query()查询的结果,第二个参数可不写，表示规定返回哪种结果，MYSQL_ASSOS-关联数组；MYSQL_NUM-数字数组；MYSQL_BOTH—两者兼有，默认值。最后一个完整的sql注入测试页面（即上述的步骤）。 初识mysql基本知识：一个数据库中可以包含多个表，一个表中的第一列叫做字段，一行的所有信息称做记录定位到一条数据的步骤：1、找到数据库2、找到数据表3、通过字段找到数据Mysql:通过mysql的各种命令对数据库进行操作。mysql的启动：1、phpstudy-&gt;其他选项菜单-&gt;cmd命令行,打开界面后输入mysql -uroot -p,回车键启动，启动之后可以输入mysql的各种命令 2、Linux系统启动mysql：sevice mysql start.mysql的各种命令：命令一般以分号结尾，除了删除列命令，alter table users drop column age，表示删除users表中age那一列。连接操作符，类似于python，and 和 or。例如：id=1 and 1=1 会输出id=1的所有信息，若是id=1 and 1=2 会输出NULL等等； 开始攻略-注入一般情况下一个sql注入页面，会有下列语句：所以我们通过union select来联合查询，Select * from users where id=-1 union select 1,2，union前后字段数必须一样，所以我们需要找到前面表中的字段数。步骤：1、判断是否存在注入以及注入是字符型还是数字型，①输入1,查询成功 ②输入1’ and ‘1’=’2,若为字符型，放进去即为id=’1’ and’1’=’2’,为永假式 ③输入1’ or ‘1’=’1,为永真式，此时输出多组数据，基本可判断该页面被注入，存在SELECT语句，且为字符型注入2、猜字段数，通过1’ or 1=1 order by n #(按照第n列排序，若n超出范围，则查询失败，找临界点)，另外，#在URL中有特殊的含义，我们需用%23表示。3、确定显示字段顺序，输入1’union select 1,2 #（%23）（#表示注释掉后面的语句）换数字多试几次，找到坑位4、找到当前数据库，输入1′ union select 1,database() #，即可找到当前数据库，database()的作用是找到当前数据库5、获取数据库中的表，输入1′ union select 1,group_concat(table_name) from information_schema.columns where table_schema=database() #，group_concat:将查询结果以一行的形式输出，information_schema.columns包含table_schema字段(表示数据库名),table_name字段（表示数据表名）,column_name字段（列名）6、获取表中的字段，输入1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #。7、下载数据，输入1′ or 1=1 union select group_concat(id,first_name,last_name),group_concat(password) from users #。写下今天关于这个的大概收获：了解了下PHP，对它的语法有了一定的认识；利用mysql对数据库进行一些操作；一个完整的sql注入测试页面；手工注入，步骤基本了解，原理有待深入。]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言]]></title>
    <url>%2F2018%2F07%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一些基本知识 什么是汇编语言简单的来说，汇编语言是一种低级语言。汇编指令：汇编指令是汇编语言中使用的一些操作符和助记符,还包括一些伪指令(如assume,end)。用于告诉汇编程序如何进行汇编的指令，它既不控制机器的操作也不被汇编成机器代码，只能为汇编程序所识别并指导汇编如何进行。CPU：中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。内存：内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。 内存是由内存芯片、电路板、金手指等部分组成的。数值表示：二进制：数字后加b;十进制：d;十六进制：h，一般没写的默认为十进制。字长：bit:最小位；byte（字节）:一个字节8位；word：2个字节；dword:4个字节寄存器：用来暂存指令、数据和地址，一个寄存器可存4个字节，即32位。寄存器种类介绍： EAX：存储函数返回值 ECX：循环计数器 EDX：指针 ESP：栈顶 EBP：栈底 ESI：源地址 EDI：目的地址 标志寄存器：一个16位的存放条件标志、控制标志寄存器，主要用于反映处理器的状态和ALU运算结果的某些特征及控制指令的执行。CF：表示进位或借位，针对无符号整数，判断是否超出表达范围等（详情百度，很清晰）寻址方式： 立即数寻址：MOV EAX,123H相当于123H=EAX 寄存器寻址：MOV EAX,EBX相当于EBX=EAX； 直接寻址：MOV EAX,[12345678H]，中括号内为源地址，其指向的数据赋给内存器EAX； 寄存器间接寻址：MOV EAX,[EBX]，EBX所存储数据为源地址，其指向的数据赋给内存器EAX；基本指令： 数据传送：MOV（传送字或字节），PUSH（进栈）,POP（出栈）,LEA（地址）,MOVSX（先符号扩展，再传送）,PUSHAD（把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈）,POPAD（把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈） 算术运算：ADD（加）,INC（加一）,SUB（减法）,DEC（）,NEG,CMP,MUL,IMUL,DIV,IDIV 逻辑运算：AND,OR,NOT,XOR（异或）,TEST,SHL（逻辑左移）,SHR（逻辑右移，低位进CF，高位补0）,SAR（算术右移低位进CF，高位不变）,ROL（循环左移）,ROR,RCL（通过进位的循环左移）,RCR 转移指令:JMP（无条件转移）,J[N]Z(E)（（不）等于时转移）,J[N]B（（不）小于转移）,JA（大于转移）,JL（小于转移）,JG（大于转移） 循环指令：LOOP（不为0时循环）,JCXZ（不为0是转移） 串操作:MOVS[B|W|D]（一位一位地赋值）,CMPS（比较）,SCAS,LODS,STOS,REP 其他指令:INT,RET,NOP,CLD,CALL]]></content>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
</search>
